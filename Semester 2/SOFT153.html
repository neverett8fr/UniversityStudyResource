<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SOFT153</title>
</head>

<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3pro.css">
<link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-teal.css">
<body style="max-width:600px">

<nav class="w3-sidebar w3-bar-block w3-card" id="mySidebar">
    <div class="w3-container w3-theme-d2">
        <span onclick="closeSidebar()" class="w3-button w3-display-topright w3-large">X</span>
        <br>
        <div class="w3-padding w3-center">
            <img class="w3-circle" src="../images/codeImage.jpg" alt="avatar" style="width:75%">
        </div>
    </div>
    <a class="w3-bar-item w3-button" href="../index.html">Index</a>
    <a class="w3-bar-item w3-button" href="semester2.html">Semester 2</a>
    <a class="w3-bar-item w3-button" href="#">?</a>
</nav>


<header class="w3-bar w3-card w3-theme">
    <button class="w3-bar-item w3-button w3-xxxlarge w3-hover-theme" onclick="openSidebar()">&#9776;</button>
    <h1 class="w3-bar-item">SOFT153</h1>
</header>

<div class="w3-container">
    <p>---- Lecture topics -----</p>
    <p>Technicalities - basic maths - functions:</p>
    <p/>BIDMAS shit
    <p/>Distributivity? -- The Distributive Law says that multiplying a number by a group of numbers added together is the same as doing each multiplication separately. Example: 3 × (2 + 4) = 3×2 + 3×4.
    <p/>Simple factoring -- common factoring, y(x + x) = 2xy -- multiplying fractions -- manipulating fractions e.g. (3/4) * (5/6) = 15/24
    <p/>Continue writing if anything unknown comes up
    <p/>



    <p/>
    <p>Functions - Differentiation and integration:</p>
    <p/>

    <p/>
    <p>Extra &  intrapolation - graphs:</p>
    <p/>

    <p/>
    <p>Counting and probability:</p>
    <p/>

    <p/>
    <p>Sets and logic:</p>
    <p/>

    <p/>
    <p>Coordinates, vectors and matrices:</p>
    <p/>


    <p/>

    <p>---- Lab Worksheets ----</p>

    <p/>---- Maths ----


    <p/>---- Coding (second half) ----
    <p/>---------------------------------
    <p/>*Polynomials research what they are
    <p/>
    <p/>Polynomial - mix of natural and real numbers, etc.??
    <p/>
    <p/>**Asymptotic behaviour
    <p/>
    <p/>**polynomial Functions
    <p/>
    <p/>
    <p/>**searching -- binary searching, linear searching, etc.
    <p/>research this -- actually quite interesting
    <p/>research their speeds and efficiency - essay basically again
    <p/>polynomial functions, etc.
    <p/>*just read the course online, easy.
    <p/>
    <p/>**derivatives, integration, etc.
    <p/>**Rayleigh Curve research
    <p/>**interpolation, extrapolation
    <p/>
    <p/>
    <p/>---------------------------------------
    <p/>
    <p/>Extrapolation and Interpolation#
    <p/>
    <p/>Extrapolation - process of extending a given set of data points with new data points (estimating based on past data)
    <p/>extra - add more on end or before start -- assumes data will continue to follow trend
    <p/>Interpolation - within the data points
    <p/>
    <p/>Fancy graphs and trees
    <p/>Graph is a set of nodes - generally
    <p/>vertices - corner points
    <p/>edges - lines
    <p/>
    <p/>**Monte Carlo Simulation --?? lookup
    <p/>
    <p/>random numbers-
    <p/>normally generate a real number between 1 and 0 with all values between 0 and 1 being equally likely
    <p/>if x:= random then:
    <p/>p(0 < x < 1) = 1
    <p/>p(0 < x < 0.5) = 0.5
    <p/>p(0.2 < x < 0.64) = 0.44
    <p/>
    <p/>
    <p/>van genuchten profile**
    <p/>
    <p/>Problem complexity**
    <p/>
    <p/>-- lookup cylcomatic complexity (cc)** --
    <p/>cc = #connected regions
    <p/>
    <p/>
    <p/>
    <p/>
    <p/>
    <p/>---------------------------
    <p/>
    <p/>
    <p/>Venn Diagrams -- Probability
    <p/>
    <p/>probability for or == p(a) + p(b) - p(a and b) --- a and b are different circles within the diagram
    <p/>this is different for mutually exclusive events
    <p/>
    <p/>
    <p/>two events cannot happen together if they are mutually exclusive
    <p/>p(a and b) = 0
    <p/>p(a or b) = p(a) + p(b)
    <p/>
    <p/>
    <p/>**lookup determining mutual exclusivity
    <p/>
    <p/>Exhaustiveness
    <p/>events are exhaustive if p(a or b or ... or z) = 1
    <p/>// it is certain that at least one event a ... z will occur#
    <p/>exhaustive and mutually exclusive -- then certain only one event will occur
    <p/>
    <p/>
    <p/>Negation
    <p/>1 = p(a) + p(a')
    <p/>
    <p/>
    <p/>Conditional Probability -- p(a or b) = p(a) given p(b)
    <p/>p(a or b) = p(a and b) / p(b)
    <p/>
    <p/>**Bayes' theroem
    <p/>
    <p/>
    <p/>
    <p/>
    <p/>
    <p/>-----------------
    <p/>
    <p/>Research what you missed***
    <p/>
    <p/>
    <p/>-----------------
    <p/>
    <p/>
    <p/>Sets**
    <p/>
    <p/>
    <p/>** Fuzzy Logic
    <p/>
    <p/>** De Morgans
    <p/>
    <p/>** Mongol databases, gaph databases //??
    <p/>
    <p/>**Composite Key
    <p/>--A composite key is a combination of two or more
    <p/>columns in a table that can be used to
    <p/>uniquely identify each row in the table when
    <p/>the columns are combined uniqueness is guaranteed,
    <p/>but when it taken individually it does not guarantee
    <p/>uniqueness.
    <p/>
    <p/>Example: OrderID and ProductID: {OrderID, ProductID}
    <p/>
    <p/>
    <p/>What is the difference between a composite key,
    <p/>primary key and foreign key? ... A primary key is
    <p/>defined as a key or database column which uniquely
    <p/>identifies each row in a database table.
    <p/>A composite key is a set of more than one key that,
    <p/>together, uniquely identifies each record
    <p/>
    <p/>??** Compound Key **?? -- research the types of keys
    <p/>
    <p/>
    <p/>Properties of Tables--
    <p/>- No two rows are the same
    <p/>- The order of rows is not significant
    <p/>- The order of columns is not significant
    <p/>- each column has a unique name
    <p/>- all attributes are atomic (cannot be sub-divided)
    <p/>- All non-key attributes are dependent on the key,
    <p/>the whole key and nothing but the key
    <p/>
    <p/>
    <p/>-- Database Normalisation
    <p/>- "Normal Forms" ** Lookup ??
    <p/>- Follow sequentially , 1st, 2nd, 3rd
    <p/>- each of the columns should contain one value
    <p/>(no more) and there should be no repeating groups
    <p/>- Can we figure out "any of the values in a row" from
    <p/>just part of the composite key
    <p/>** this was asking if any value is present in other,
    <p/>table, stopping duplication -- e.g. cource code link to
    <p/>another table with course name and teacher, etc.
    <p/>*** lookup from slide i think it was
    <p/>asking if any attribute can be determined from other
    <p/>attribute in the table
    <p/>- Can we figure out "any of the values in a row" from
    <p/>any of the other values in the same row
    <p/>
    <p/>
    <p/>
    <p/>--------------------------
    <p/>- Flow Diagram Stuff Pretty easy
    <p/>- Pseudocode too
    <p/>
    <p/>- Flow
    <p/>-- Rectangle = General Statement
    <p/>-- Rhombus / slanted = Input / Output
    <p/>-- Diamond = Conditional Branching = If statements
    <p/>-- Oval = Start / Stop
    <p/>
    <p/>-- Drawback
    <p/>--- Only usable for small size programs
    <p/>--- they do not well support for / while loops / or recursion
    <p/>--- they do lead to an uncontrolled use of "goto"
    <p/>--- this results in hard to read / "Spaghetti Code"
    <p/>
    <p/>
    <p/>- Structured Programming
    <p/>-- Break problems into pieces according to the problem structure
    <p/>-- break pieces into smaller pieces, etc.
    <p/>-- don't refer to specific language elements early
    <p/>-- pieces interact via "interfaces" but are otherwise independent
    <p/>-- project - modules - functions - fragments
    <p/>
    <p/>
    <p/>
    <p/>- Structogram / Nassi Shneiderman Diagrams
    <p/>-- https://en.wikipedia.org/wiki/Nassi%E2%80%93Shneiderman_diagram
    <p/>-- Graphical representation for Structured programming
    <p/>
    <p/>-- Structogram: Process
    <p/>--- Rectangle / Square
    <p/>--- can contain a single statement or a bigger functional block depending on the resolution
    <p/>--- flow enters on the top and exits on the bottom of the element
    <p/>
    <p/>-- Structogram: Decision
    <p/>--- Triangle followed by 2 triangles with T or F and then a process block
    <p/>--- if condition x is true, follow true side
    <p/>
    <p/>-- Structogram:
    <p/>--- Square inside square: for - & while loop
    <p/>--- Inside Square at bottom
    <p/>---- process block embedded in loop where the loops exit condition is evaluated at the beginning
    <p/>--- Inside Square at top: do - while loop
    <p/>---- process block embedded in loop where the loops exit condition is evaluated at the end - do while loop, repeat until loop
    <p/>
    <p/>-- structogram: Break / Continue
    <p/>--- Similar for for- and while loops
    <p/>--- look at powerpoint Soft153 - 01b
    <p/>
    <p/>-- structogram: Logic Example
    <p/>--- look at powerpoint Soft153 - 01b
    <p/>--- e.g. ¬, ?, etc.
    <p/>
    <p/>-- Structogram: Nested Loops
    <p/>--- Loop within loop
    <p/>--- Matric Multiplication?
    <p/>--- See powerpoint Soft153 - 01b
    <p/>
    <p/>
    <p/>- Prime Numbers - if divisible by only itself and 1 and no number inbetween it is prime
    <p/>
    <p/>
    <p/>- An idea of structograms (Nassi/Shneiderman diagrams) as a first step to develop structured code
    <p/>- Flow Diagrams - as an alternative to structograms that, however, does not support structured programming
    <p/>
    <p/>
    <p/>
    <p/>-------------------------------
    <p/>- Memory
    <p/>
    <p/>- Number types and their representation
    <p/>- Strong and weekly typed programming languages
    <p/>- arrays, collections and their representations
    <p/>
    <p/>- values, addresses, references, and pointers
    <p/>
    <p/>
    <p/>- Fixed point numbers
    <p/>-- approximation of real numbers with fixed number of digits after the decimal point
    <p/>-- 1.234, 890.32, -12, etc.
    <p/>-- can speed up mathematical calculations; especially on machines without floating point unit - old / handheld
    <p/>-- Not explicity supported by c#
    <p/>
    <p/>- Floating point number
    <p/>-- another representation of real numbers
    <p/>-- significant digit x base ^ exponent
    <p/>-- -1.245 x 10 ^ 32, 0,123 x 2 ^ 123, 123.4 x 10 ^ -10, etc.
    <p/>-- can cover a much larger range than fixed-points
    <p/>-- need more storage ; are potentially less precise (cant exactly get number, half, quarter, eighth, etc.)
    <p/>-- need rescaling of the exponent
    <p/>-- are supported by floating point units
    <p/>
    <p/>-- Floating Point types
    <p/>--- single = 24 bit precision = 32 bits = 8 exponent
    <p/>--- double = 53 bit precision = 64 bits = 11 exponent
    <p/>
    <p/>- Implicit and Explicit Conversions*
    <p/>-- implicit conversions = change types or values according to rules built-in to a programming language / run-time environment
    <p/>-- explicit conversions = use keywords to specifically request conversions
    <p/>-- conversions cost time
    <p/>
    <p/>
    <p/>- Arrays
    <p/>-- Integer array in memory - byte order can differ
    <p/>--- a[0], a[1], a[2] -- a[0] = most significant byte, a[2] = least significant byte
    <p/>--- e.g. 1000 change to 1001 not much of a change, but change to 2000 then big change
    <p/>-- Array Representation
    <p/>--- Array elements all have the same size in memory; the size of their basic type
    <p/>--- elements are typically consecutively laid out in memory starting at some location, with higher indexed elements at higher memory locations
    <p/>-- Higher-Dimensional arrays?**?
    <p/>--- Data stored linearly in memory: elements with the most right index are stored first them the next dimension to the left, and so on
    <p/>--- e.g. for a two-dimensional array the first row is stored first, then the second, and so on.
    <p/>--- e.g. array[,] arrayName = new array[2,3];
    <p/>-- String arrays ****????
    <p/>--- they are still the same size, they hold references to string, not the actual string
    <p/>--- the array stores fixed size "references" to the strings
    <p/>
    <p/>
    <p/>
    <p/>
    <p/>- CPUs can load linear memory segments quickly
    <p/>- The CPU cache allows very fast operation
    <p/>- Badly aligned data can cost a factor of 10 in speed
    <p/>
    <p/>- ?**Struct (in C)**? - i assume like VB??
    <p/>- **Look difference between structure and a class** one public obviously, etc.
    <p/>-- *Classes don't contain methods of classes?* maybe??
    <p/>-- struct - define variables e.g. record = firstName && lastName && age, etc.
    <p/>--- class might have a method to return?? lookup to know for certain
    <p/>--- differences between structures and classes --> see modules about object oriented programming (oop)
    <p/>--- Classes more complicated - they can have methods, etc.
    <p/>--- https://pediaa.com/what-is-the-difference-between-class-and-structure/
    <p/>
    <p/>-- ??**enum types*** List of tags
    <p/>-- ??**unions*** access the same memory as different types
    <p/>
    <p/>-- Dealing directly with the physical addresses when changing memory is considered unsafe
    <p/>-- Preferable to change the variable, etc.
    <p/>-- The address operator "&" applied to a varible returns its "physical" address
    <p/>--- e.g. x = 235 creates a variable with value 235
    <p/>--- e.g. *px = &x pointer to int is set to addr. of x
    <p/>--- the address is "deferenced" using the "*" operator; this returns the value at the target address
    <p/>---- * px = 22; reset x from 235 to 22
    <p/>
    <p/>--??**Unsafe Void**??
    <p/>
    <p/>
    <p/>
    <p/>-------------
    <p/>
    <p/>- Iteration and Recursion
    <p/>
    <p/>- Recursion is a way to define objects, equations, funcitions, etc. that refer to themselves - this can lead to very natural and appealing algorithms for some problems
    <p/>
    <p/>- Loops, arrays, linear search, iterative binary searach, recursion, recursive binary search, towers of hanoi??
    <p/>
    <p/>- Linear Search
    <p/>-- go through array start at 0 and check each element against search value, if found return "true"
    <p/>
    <p/>- binary search
    <p/>-- needs on average n/2 iterations and n in the worse case
    <p/>-- if we know the array is sorted we can be quicker
    <p/>-- open dictionary in middle, if word is same then word found, if smaller look at midpoint of left half, if larger look at midpoint of right half, repeat until found
    <p/>-- e.g. guess number x = 20 -- guess 50, no smaller -- guess 25, no smaller -- guess 13, no bigger -- guess 20, yes thats right




</div>


<footer class="w3-container w3-theme w3-margin-top">
    <h3>Nathan Everett</h3>
</footer>

<script>
    closeSidebar();
    function openSidebar() {
        document.getElementById("mySidebar").style.display = "block";
    }

    function closeSidebar() {
        document.getElementById("mySidebar").style.display = "none";
    }
</script>

</body>

</html>